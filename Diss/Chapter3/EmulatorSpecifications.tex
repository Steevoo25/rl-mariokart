% !TEX root =  ../Dissertation.tex

\chapter{Emulator Specification}
\section{Motivations}
Dolphin Emulator \cite{DolphinEmulator} has many features 'out-of-the-box' that make it suited for my use case. These include, but are not limited to:
\subsection{Savestates}
The savestate system allows for saving to and loading from predefined 'slots' and files. This is extremely useful when performing episodic RL as the environment will need to  reset when a terminal state is reached, setting the next state to an initial state $s_0$.
\subsection{Framedumps}
Framedumping saves the current frame's pixel data as jpeg files as soon as they are rendered. This allows us to access this data without any interaction with Dolphin itself. The pixel data, being the input to the D-RL agent, is extremely important as without it the neural network's input data size would be greatly decreased, leading to a potentially ineffective agent.
\subsection{API Access}
An unofficial version of Dolphin with intergrated API access has been created by the TAS community. Currently known as \textit{Pycore}\cite{DolphinWithScriptingSupport}, this version provides an API with the emulation, allowing for programmatic access and control of a few core features, including:
\begin{itemize}
    \item Waiting for the next frame to be drawn
    \item Reading a given location in memory
    \item Setting the current state of an emulated controller
    \item Loading a savestate \footnote{As per\href{https://github.com/TASLabz/dolphin/issues/123}{Issue \#123}, this is currently not working, however a workaround involving pressing a hotkey assigned to loading a savestate slot is effective}
\end{itemize}
\subsection{Multiple Concurrent Controllers}
Dolphin also supports local multiplayer, allowing multiple emulated or real controllers connected at one time. This leads to the possibility of playing against a trained agent, possibly comparing different amounts of training time to human performance.
\subsection{Cheat Codes}
Due to the age and nature of the game, many cheat codes for Mariokart Wii have been created, known as \textit{Gecko Codes}. Traditionally cheat codes are synonymous with gaining an unfair advantage in online play, however many of these differ from that. The two that I used during this project gave me a fully completed game save (unlocking all characters, vehicles and tracks) and displays many key values from Memory on the screen, known as the \textit{Debug Panel}\cite{GeckoCode}.
\begin{figure}[hbt]
    \centering
    \includegraphics[width=0.7\textwidth]{Figures/debug-panel.png}
    \caption{A screenshot of the game with the \textit{Debug Panel} cheat enabled}
    \label{fig:gecko-code}
\end{figure}
\section{Controller}
Mariokart Wii permits 4  controller types:
\begin{itemize}
    \item A standard Wii Remote turned sideways and ususally in a 'Wii Wheel' accessory
    \item A Wii Remote with the 'nunchuck' extension
    \item A Wii Classic Controller
    \item A GameCube Controller\footnote{\href{https://www.nintendo.co.uk/Hardware/Nintendo-History/Nintendo-GameCube/Nintendo-GameCube-627129.html}{Nintendo's predecessor} console to the Wii, which the Wii supported}
\end{itemize}
\begin{figure}[ht]
    \centering
    \subfloat[A Wii Remote in a 'Wii Wheel']{\includegraphics[width=0.17 \textwidth]{Figures/wii-wheel.jpg}\label{fig:wii-wheel}}
    \hfill
    \subfloat[The 'nunchuck' extension]{\includegraphics[width=0.12\textwidth]{Figures/wii-nunchuck.jpg}\label{fig:wii-nunchuck}}
    \hfill
    \subfloat[A Wii Classic Controller]{\includegraphics[width=0.25\textwidth]{Figures/wii-classic.jpg}\label{fig:wii-classic}}
    \hfill
    \subfloat[A GameCube Controller]{\includegraphics[width=0.17\textwidth]{Figures/gc-controller.jpg}\label{fig:gc-controller}}
    \caption{Mariokart Wii's permitted controllers}
\end{figure}
Out of those available, I chose to use a GameCube Controller. The main reason for this is the clear distinction between its inputs.In contrast, the Wii Remote uses motion controls for steering and other actions, and as these need to be represented formally, I decided that purely button or stick inputs would be the best way forwards, eliminating any uncertainty in regards to motion actuation zones/speeds. The main actions available to control the kart are:
\renewcommand{\labelitemii}{$\rightarrow$}
\begin{itemize}
    \item 'A' Button = Accelerate
    \item 'B' Button = Performs 2 different actions:\begin{itemize}
        \item Brake (when no direction is held)
        \item Drift in given direction\footnote{A drift's direction cannot be changed during a drift, but can be adjusted. That is, a drift that is started while holding right will always drift to the right, but keeping 'B' held and steering left will make the turn less sharp.}
    \end{itemize}
    \item 'Up' Button = Performs a wheelie, increasing top speed, but heavily decreasing handling\footnote{A wheelie can only be performed on 'bike' vehicles} \footnote{The button does not need to be held to perform the wheelie. Once pressed, the wheelie will continue for a short period, unless it is cancelled by pressing 'B'}
    \item Main Control Stick = Steers the kart/dictates direction of drift
\end{itemize}
\section{Memory Access}
The values shown on-screen in the \textit{Debug Panel} provide a lot of information about the current state of the kart, giving me lots of options to consider. It was clear that I needed a method for finding memory addresses, given its value. A tool for this type of process exists already and is called Dolphin Memory Engine\cite{DolphinMemoryEngine}. This hooks to the running Dolphin process and accesses the emulated memory, providing filtering and searching capabilities
\subsection{Method}
The method I used to find memory addresses was an iterative search process. Lets say I am searching for the memory address that contains the current speed of the kart. We know that it will most likely be a float, as speed is real-valued. To get a baseline, I search memory for any float with value 0, 'discarding' all other locations . I then accelerate up to a certain speed and search the remaining memory for that value. A repetition of this 'elimination' style search proved effective in finding the locations of all the values I required, these being:
\begin{figure}[bt]
    \centering
    \includegraphics{Preamble/BirmCrest.png}
    \caption{Screenshot of Dolphin Memory Engine}
    \label{fig:dme}
\end{figure}
\begin{itemize}
    \item Speed = The current speed of the vehicle
    \item Race Completion \% = A number from 0 to 4 representing the vehicle's progress through the course. Where the whole number portion represents the current lap and the decimal portion represents the progress through that lap.
    \item Miniturbo (MT) charge = (when drifting) How long a drift has been held for
    \item Wheelie = Whether the vehicle is currently performing a wheelie
    \item Road Type = What type of road surface the vehicle is on
\end{itemize}
Once found, I stored the addresses to read during runtime. Utilising the memory module of the API, giving live access to the emulated memory.
\begin{table}[b]
    \centering
    \begin{tabular}{l|c|c|c}
    \textbf{Name}  & \textbf{Location} & \textbf{Type (in Memory)} & \textbf{Range}\\
    \hline
     Speed  &        \texttt{0x80E4C678} & 32-bit Float  & $$[0, 113.4]$$\\
     Completion  &   \texttt{0x80E43708} & 32-bit Float  & $$[0, 4] $$\\
     X Position  &   \texttt{0x80E4DAE8} & 32-bit Float  & $$[-150,000, 150,000] $$\\
     Z Position  &   \texttt{0x80E4DAF0} & 32-bit Float  & $$[-150,000, 150,000] $$\\
     MT Charge &     \texttt{0x80E4C756} & 16-bit Integer& $$\{0,270\}$$\\
     Wheelie State & \texttt{0x90284F04} & 16-bit Integer& $$\{0,1\}$$\\
     Road Type &     \texttt{0x80E51CE8} & 16-bit Integer& $$ \{0,7\} $$\\
    \end{tabular}
    \caption{Memory Addresses in Mario Kart Wii's emulated memory}
    \label{tab:memory-addresses}
\end{table}